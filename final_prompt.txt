You are given a small Python repository where the documentation has drifted from the real implementation over time. Your job is to “fix the outdated documentation” so that a new contributor can follow the docs and get the same behavior the code actually provides today.

Do not assume the docs are correct; treat the code as the source of truth unless you find an actual bug that prevents the project from running.

**Scope**
- Update project documentation to accurately describe current behavior.
- Update or replace outdated tests so the test suite matches current behavior and can be run with minimal setup.
- Keep runtime behavior changes to a minimum; only change code if you must to make the project executable or to fix an obvious defect (if you do, explain why).

**Hard constraints**
- Do NOT add heavy dependencies. Prefer standard library solutions. If you keep any non-stdlib test runner, you must document it explicitly.
- Do NOT “paper over” mismatches by removing documentation; update it to be correct and useful.

**What to do**
1. Read the docs and code, then write a short “Mismatch Report” in your response:
   - Bullet list of each documentation claim that doesn’t match current behavior.
   - For each item, name the doc location (e.g., README.md, CONFIG.md, DESIGN.md) and the implementation location (e.g., src/config.py, src/workflow.py, src/flags.py, src/cli.py).
2. Update documentation so it matches the actual implementation:
   - Fix the quick start to use the real config format and real CLI invocation/output.
   - Ensure configuration keys, defaults, environment variables, feature-flag semantics, ordering rules, failure/stop behavior, and audit storage backend are all documented accurately.
   - Add a short “Troubleshooting / Common gotchas” section for the most likely confusion points.
3. Make running + verifying the repo straightforward:
   - Provide (or update) an example config file in the repo root (e.g., `config.json`) that actually works with the current loader.
   - Ensure the documented run command works on a clean machine with Python installed.
4. Fix tests to be aligned and runnable with minimal friction:
   - If tests currently assume old behavior, update them to assert current behavior.
   - Prefer `unittest` (stdlib) so `python -m unittest` works without installing anything.
   - If you choose not to use `unittest`, document the exact install + run steps in README.md.

**Deliverables**
- Edited files in-place (docs + tests, and only necessary code changes).
- In your final response, include:
  - “Mismatch Report” (bullets)
  - “What I changed” (bullets)
  - “How to run” commands (copy/paste)
  - “How to test” commands (copy/paste)

**Validation (you must make these commands succeed)**
- Run the CLI with your example config:
  - `python -m src.cli --config ./config.json`
- Run the tests:
  - `python -m unittest`

**Notes**
- Don’t try to restore the old promised behavior by rewriting the engine unless you find a true bug; the primary goal is accurate, current documentation.
- If anything is genuinely ambiguous (multiple plausible intended behaviors), ask a clarifying question **once**, propose a default, and proceed with that default while clearly stating it.